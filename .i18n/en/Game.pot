msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Mon Apr 15 15:40:58 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"If the goal is exactly one of the assumption, then `assumption` will close\n"
"the goal automatically.\n"
"\n"
"### Example\n"
"If it looks like this in the top right hand box:\n"
"```\n"
"A B C : Œ©\n"
"h1 : A = B\n"
"h2 : B = C\n"
"‚ä¢ A = B\n"
"```\n"
"\n"
"then\n"
"\n"
"`assumption`\n"
"\n"
"will close the goal."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"If `h` is a proof of `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s.\n"
"\n"
"**Variants:** `rw [‚Üê h]` changes\n"
"`Y` to `X` and\n"
"`rw [h] at h2` changes `X` to `Y` in hypothesis `h2` instead\n"
"of the goal.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do 'substituting in'. There\n"
"are two distinct situations where use this tactics.\n"
"\n"
"1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\n"
"in your local context (the box in the top right)\n"
"and if your goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`'s.\n"
"\n"
"2) The `rw` tactic will also work with proofs of theorems\n"
"which are equalities (look for them in the drop down\n"
"menu on the left, within Theorem Statements).\n"
"\n"
"**Important note:** if `h` is not a proof of the form `A = B`\n"
"or `A ‚Üî B` (for example if `h` is a function, an implication,\n"
"or perhaps even a proposition itself rather than its proof),\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw (P = Q)` is never correct: `P = Q` is the true-false\n"
"statement itself, not the proof.\n"
"If `h : P = Q` is its proof, then `rw [h]` will work.\n"
"\n"
"**Pro tip 1:** If `h : A = B` and you want to change\n"
"`B`s to `A`s instead, try `rw [‚Üêh]` (get the arrow with `\\l`,\n"
"note that this is a small letter L, not a number 1).\n"
"\n"
"### Example\n"
"If it looks like this in the top right hand box:\n"
"```\n"
"A B C : Point\n"
"h1 : A = B\n"
"h2 : B = C\n"
"‚ä¢ A = C\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [h1]`\n"
"\n"
"will change the goal into `‚ä¢ B = C`.\n"
"\n"
"### Example\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if your local context looks like this:\n"
"```\n"
"A B C : Point\n"
"h1 : A = C\n"
"h2 : A = B\n"
"‚ä¢ B = C\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : C = B` (remember operator precedence)."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"If the goal is `‚ä¢ X` then `exact x` will close the goal if\n"
"and only if `x` is a term of type `X`.\n"
"\n"
"## Details\n"
"\n"
"Say `P`, `Q` and `R` are types (i.e., what a mathematician\n"
"might think of as either sets or propositions),\n"
"and the local context looks like this:\n"
"\n"
"```\n"
"p : P,\n"
"h : P ‚Üí Q,\n"
"j : Q ‚Üí R\n"
"‚ä¢ R\n"
"```\n"
"\n"
"If you can spot how to make a term of type `R`, then you\n"
"can just make it and say you're done using the `exact` tactic\n"
"together with the formula you have spotted. For example the\n"
"above goal could be solved with\n"
"\n"
"`exact j(h p)`\n"
"\n"
"because `j(h p)` is easily checked to be a term of type `R`\n"
"(i.e., an element of the set `R`, or a proof of the proposition `R`)."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"`intro p` will turn a goal `‚ä¢ P ‚Üí Q` into a hypothesis `p : P`\n"
"and goal `‚ä¢ Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\n"
"If `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\".\n"
"\n"
"## Details\n"
"\n"
"If your goal is a function or an implication `‚ä¢ P ‚Üí Q` then `intro`\n"
"will always make progress. `intro p` turns\n"
"\n"
"`‚ä¢ P ‚Üí Q`\n"
"\n"
"into\n"
"\n"
"```\n"
"p : P\n"
"‚ä¢ Q\n"
"```\n"
"\n"
"The opposite tactic to intro is `revert`; given the situation\n"
"just above, `revert p` turns the goal back into `‚ä¢ P ‚Üí Q`.\n"
"\n"
"**Variant:** Instead of calling `intro` multiple times, you can put several names after `intro`.\n"
"That is, `intro h‚ÇÅ h‚ÇÇ` is equivalent to `intro h‚ÇÅ; intro h‚ÇÇ`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is an implication $P\\implies Q$ then Lean writes\n"
"this as `‚ä¢ P ‚Üí Q`, and `intro p,` can be thought of as meaning\n"
"\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n"
"$P$ is true\". The goal changes to `‚ä¢ Q` and the hypothesis `p : P`\n"
"appears in the local context."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"If the goal is `P ‚àß Q` or `P ‚Üî Q` then `constructor` will break it into two goals.\n"
"\n"
"## Details\n"
"\n"
"If `P Q : Prop` and the goal is `‚ä¢ P ‚àß Q`, then `constructor` will change it into\n"
"two goals, namely `‚ä¢ P` and `‚ä¢ Q`.\n"
"\n"
"If `P Q : Prop` and the goal is `‚ä¢ P ‚Üî Q`, then `constructor` will change it into\n"
"two goals, namely `‚ä¢ P ‚Üí Q` and `‚ä¢ Q ‚Üí P`.\n"
"\n"
"## Example\n"
"\n"
"If your local context (the top right window) looks like this\n"
"```\n"
"X : Type\n"
"A B : set X\n"
"x : X\n"
"‚ä¢ x ‚àà A ‚Üî x ‚àà B\n"
"```\n"
"\n"
"then after\n"
"\n"
"`constructor`\n"
"\n"
"it will look like this:\n"
"\n"
"```\n"
"2 goals\n"
"X : Type\n"
"A B : set X\n"
"x : X\n"
"‚ä¢ x ‚àà A ‚Üí x ‚àà B\n"
"\n"
"\n"
"X : Type\n"
"A B : set X\n"
"x : X\n"
"‚ä¢ x ‚àà B ‚Üí x ‚àà A\n"
"```\n"
"\n"
"You can isolate each of the two goals by inserting a `¬∑` (type it with `\\.`) for each of them, like so:\n"
"```\n"
"constructor\n"
"¬∑ tac1\n"
"  tac1'\n"
"¬∑ tac2\n"
"  tac2'\n"
"```\n"
"Here, `tac1` and `tac1'` are for the first goal, while `tac2` and `tac2'` are for the second."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"The `use` tactic works on the goal that looks like `‚ä¢ ‚àÉ x, P x`, where the symbol **`‚àÉ`** is read as **\"there exists\"** and\n"
"**`P x`** can be understood as **\"P is an element of x\"**, which could also be written as **`P ‚àà x`**.\n"
"In this case, the whole goal can be interpreted as **\"there exists x such that P is an element of x\"**.\n"
"Then, the `use` tactic is useful. If we know that an object `a` satisfies the  property `x`, then `use a`\n"
"will simplify the goal into ‚ä¢ P a.\n"
"\n"
"## Example\n"
"If your goal is `‚ä¢ ‚àÉ n : natural_numbers, 1 + x = x + n` then `use 1` will\n"
"turn the goal into `‚ä¢ 1 + x = x + 1`, and the rather more unwise `use 0` will\n"
"turn it into the impossible-to-prove `‚ä¢ 1 + x = x + 0`."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"`have h : P,` will create a new goal of creating a term of type `P`, and will add `h : P` to the hypotheses for the goal you were working on.\n"
"\n"
"## Details\n"
"If you want to name a term of some type (because you want it in your local context for some reason), and if you have the formula for the term, you can use have to give the term a name.\n"
"\n"
"## Example (have q := ... or have q : Q := ...)\n"
"If the local context contains\n"
"\n"
"```\n"
"f : P ‚Üí Q\n"
"p : P\n"
"```\n"
"then the tactic `have q := f(p)` will add `q` to our local context, leaving it like this:\n"
"\n"
"```\n"
"f : P ‚Üí Q\n"
"p : P\n"
"q : Q\n"
"```\n"
"\n"
"If you think about it, you don't ever really need `q`, because whenever you think you need it you coudl just use `f(p)` instead. But it's good that we can introduce convenient notation like this.\n"
"\n"
"## Example (have q : Q)\n"
"A variant of this tactic can be used where you just declare the type of the term you want to have, finish the tactic statement with a comma and no :=, and then Lean just adds it as a new goal. The number of goals goes up by one if you use `have` like this.\n"
"\n"
"For example if the local context is\n"
"\n"
"```\n"
"P Q R : Prop/Type,\n"
"f : P ‚Üí Q,\n"
"g : Q ‚Üí R,\n"
"p : P\n"
"‚ä¢ R\n"
"```\n"
"then after `have q : Q`, there will be the new goal\n"
"\n"
"```\n"
"f : P ‚Üí Q,\n"
"g : Q ‚Üí R,\n"
"p : P,\n"
"‚ä¢ Q\n"
"```\n"
"and your original goal will have `q : Q` added to the list of hypotheses."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"`rcases` is a tactic which works on hypotheses.\n"
"If `h : P ‚àß Q` or `h : P ‚Üî Q` is a hypothesis then `rcases h`\n"
"will remove `h`\n"
"from the list of hypotheses and replace it with the *ingredients* of `h`,\n"
"i.e. `left : P` and `right : Q`, or `mp : P ‚Üí Q` and `mpr : Q ‚Üí P`. Also\n"
"works with `h : P ‚à® Q` and with `h : ‚àÉ x, P x`.\n"
"The syntax `rcases h with ‚ü®h1, h2‚ü©` renames the new hypotheses as `h1` and `h2`.\n"
"\n"
"## Details\n"
"\n"
"How does one prove `P ‚àß Q`? The way to do it is to prove `P` and to\n"
"prove `Q`. There are hence two ingredients which go into a proof of\n"
"`P ‚àß Q`, and the `rcases` tactic extracts them.\n"
"\n"
"More precisely, if the local context contains\n"
"```\n"
"h : P ‚àß Q`\n"
"```\n"
"\n"
"then after the tactic `rcases h with ‚ü®p, q‚ü©` the local context will\n"
"change to\n"
"```\n"
"p : P\n"
"q : Q\n"
"```\n"
"and `h` will disappear.\n"
"\n"
"Similarly `h : P ‚Üî Q` is proved by proving `P ‚Üí Q` and `Q ‚Üí P`,\n"
"and `rcases h with ‚ü®hpq, hqp‚ü©` will delete our assumption `h` and\n"
"replace it with\n"
"```\n"
"hpq : P ‚Üí Q\n"
"hqp : Q ‚Üí P\n"
"```\n"
"\n"
"Be warned though -- `rw [h]` works with `h : P ‚Üî Q` (`rw` works with\n"
"`=` and `‚Üî`), whereas you cannot rewrite with an implication.\n"
"\n"
"`rcases` also works with hypotheses of the form `P ‚à® Q`. Here the situation\n"
"is different however.\n"
"To prove `P ‚à® Q` you need to give either a proof of `P` *or* a proof\n"
"of `Q`, so if `h : P ‚à® Q` then r`rcases h` will change one goal\n"
"into two, one with `p : P` and the other with `q : Q`."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"`left` and `right` work on the goal, and they change\n"
"`‚ä¢ P ‚à® Q` to `‚ä¢ P` and `‚ä¢ Q` respectively.\n"
"## Details\n"
"The tactics `left` and `right` work on a goal which is a type with\n"
"two constructors, the classic example being `P ‚à® Q`.\n"
"To prove `P ‚à® Q` it suffices to either prove `P` or prove `Q`,\n"
"and once you know which one you are going for you can change\n"
"the goal with `left` or `right` to the appropriate choice."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"`left` and `right` work on the goal, and they change\n"
"`‚ä¢ P ‚à® Q` to `‚ä¢ P` and `‚ä¢ Q` respectively.\n"
"## Details\n"
"The tactics `left` and `right` work on a goal which is a type with\n"
"two constructors, the classic example being `P ‚à® Q`.\n"
"To prove `P ‚à® Q` it suffices to either prove `P` or prove `Q`,\n"
"and once you know which one you are going for you can change\n"
"the goal with `left` or `right` to the appropriate choice."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"Generates two goals corresponding to a given statement being\n"
"true or false\n"
"\n"
"## Details\n"
"\n"
"Suppose that we want to prove a statement `P x`, where `x`\n"
"is some number. We may know how to prove it when `x ‚â§ 5`\n"
"and also when `x > 5`, but using a different method.\n"
"In this situation, using `by_cases h : x ‚â§ 5` will produce\n"
"two new goals, the first one with `h : x ‚â§ 5` in the context\n"
"and the second one with `h : ¬¨ x ‚â§ 5`."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"If `h : P ‚Üí Q` is a hypothesis, and the goal is `‚ä¢ Q` then\n"
"`apply h` changes the goal to `‚ä¢ P`.\n"
"\n"
"## Details\n"
"\n"
"If you have a function `h : P ‚Üí Q` and your goal is `‚ä¢ Q`\n"
"then `apply h` changes the goal to `‚ä¢ P`. The logic is\n"
"simple: if you are trying to create a term of type `Q`,\n"
"but `h` is a function which turns terms of type `P` into\n"
"terms of type `Q`, then it will suffice to construct a\n"
"term of type `P`. A mathematician might say: \"we need\n"
"to construct an element of $Q$, but we have a function $h:P\\to Q$\n"
"so it suffices to construct an element of $P$\". Or alternatively\n"
"\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\n"
"so it suffices to prove $P$\"."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"The `tauto` tactic is a high-level tactic which tries to prove statements that follow tautologically\n"
"from the hypotheses.\n"
"\n"
"## Details\n"
"The `tauto` tactic does basic automation. It breaks down assumptions of the form `_ ‚àß _`, `_ ‚à® _`, `_ ‚Üî _` and `‚àÉ _, _`,\n"
"and splits a goal of the form `_ ‚àß _`, `_ ‚Üî _` or `‚àÉ _, _` until it can be proved using trivialities.\n"
"\n"
"## Example\n"
"``example (p q r : Prop) : p ‚à® (q ‚àß r) ‚Üî (p ‚à® q) ‚àß (r ‚à® p ‚à® r) := by tauto``"
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"Changes the goal to `‚ä¢ false`.\n"
"\n"
"## Details\n"
"\n"
"This may seem hard to prove,\n"
"but it is useful when we have a contradiction in the hypotheses.\n"
"\n"
"For example, if we have `h : ¬¨ P` as a hypothesis and we apply `exfalso`\n"
"we can then `apply h` to transform the goal into `‚ä¢ P`."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"\n"
"It changes the goal from `‚ä¢ P` to `‚ä¢ false` and adds a new hypothesis\n"
"of the form `h : ¬¨ P` to the local context.\n"
"\n"
"## Real Life Example\n"
"\n"
"If we want to prove `‚ä¢ SKY_ALWAYS_BLUE`, but we assume that `h : SKY_GREY_WHEN_RAINS`,\n"
"type `by_contra z` to add `z : ¬¨ (SKY_ALWAYS_BLUE)` to the local context and change the\n"
"goal into `‚ä¢ false`. Then, argue that `h : SKY_GREY_WHEN_RAINS` to finish the proof."
msgstr ""

#: Game.TacticDoc
msgid "## Summary\n"
"The `simp` tactic is a high-level tactic which tries to prove equalities using facts in its database.\n"
"\n"
"## Details\n"
"The `simp` tactic does basic automation. It uses lemmas already proved that have been tagged\n"
"with a special label, to simplify either a goal or a hypothesis."
msgstr ""

#: Game.TheoremDoc
msgid "The line through `A` and `B`"
msgstr ""

#: Game.TheoremDoc
msgid "Two points `A` and `B` are on the `same_side` of `‚Ñì` if they do not belong\n"
"to `‚Ñì`, and there is not point in `‚Ñì` between `A` and `B`."
msgstr ""

#: Game.TheoremDoc
msgid "Three points `A`, `B`, `C` are `collinear` if there is a line containing them:\n"
"`collinear A B C ‚Üî ‚àÉ ‚Ñì, A ‚àà ‚Ñì ‚àß B ‚àà ‚Ñì ‚àß C ‚àà ‚Ñì`."
msgstr ""

#: Game.TheoremDoc
msgid "The line through `A` and `B` contains `A`"
msgstr ""

#: Game.TheoremDoc
msgid "The line through `A` and `B` contains `B`"
msgstr ""

#: Game.TheoremDoc
msgid "If two distinct points `P` and `Q` are on the line `‚Ñì`, then `‚Ñì = line_trhough P Q`"
msgstr ""

#: Game.TheoremDoc
msgid "If two lines contain two different points, then they are equal"
msgstr ""

#: Game.TheoremDoc
msgid "The line through two points does not depend on the order of the two points"
msgstr ""

#: Game.TheoremDoc
msgid "If two points lie in two distinct lines, then they are equal"
msgstr ""

#: Game.TheoremDoc
msgid "There exists three distinct non-collinear points"
msgstr ""

#: Game.TheoremDoc
msgid "One can show that two lines are different if there is a point in one of them and not in the other"
msgstr ""

#: Game.TheoremDoc
msgid "If two lines are different, then there is a point in the first one and not in the second"
msgstr ""

#: Game.TheoremDoc
msgid "There exists three pairwise distinct lines"
msgstr ""

#: Game.TheoremDoc
msgid "Every line contains at least two points"
msgstr ""

#: Game.TheoremDoc
msgid "(A * B * C) ‚Üî (C * B * A)"
msgstr ""

#: Game.TheoremDoc
msgid "(A * B * C) ‚Üí A ‚â† B"
msgstr ""

#: Game.TheoremDoc
msgid "(A * B * C) ‚Üí A ‚â† C"
msgstr ""

#: Game.TheoremDoc
msgid "(A * B * C) ‚Üí B ‚â† C"
msgstr ""

#: Game.TheoremDoc
msgid "(A * B * C) ‚Üí ‚àÉ ‚Ñì, A ‚àà ‚Ñì ‚àß B ‚àà ‚Ñì ‚àß C ‚àà ‚Ñì"
msgstr ""

#: Game.TheoremDoc
msgid "If A B C D E F are any six points such that the set {A, B, C} = {D, E, F},\n"
"then A, B, C are collinear if and only if D, E, F are."
msgstr ""

#: Game.TheoremDoc
msgid "A ‚â† B ‚Üí ‚àÉ C, A * B * C"
msgstr ""

#: Game.TheoremDoc
msgid "((A * B * C) ‚àß ¬¨ ( B * A * C ) ‚àß ¬¨ (A * C * B)) ‚à®\n"
"(¬¨ (A * B * C) ‚àß ( B * A * C ) ‚àß ¬¨ (A * C * B)) ‚à®\n"
"(¬¨ (A * B * C) ‚àß ¬¨ ( B * A * C ) ‚àß (A * C * B))"
msgstr ""

#: Game.TheoremDoc
msgid "Given three non-collinear points A B C and a line ‚Ñì not containing any of them, suppose there\n"
"  is a point D ‚àà ‚Ñì between A and B. Then there is a point in ‚Ñì between A and C or between B and C."
msgstr ""

#: Game.TheoremDoc
msgid "Given three distinct collinear points A, B and C, if B lies between A and C, then A does not lie between B and C."
msgstr ""

#: Game.TheoremDoc
msgid "There are no points between a point and itself."
msgstr ""

#: Game.TheoremDoc
msgid "Betweenness is symmetric: A * B * C ‚Üî C * B * A"
msgstr ""

#: Game.TheoremDoc
msgid "Given A * B * C, if B and C are on a line r then so is A"
msgstr ""

#: Game.TheoremDoc
msgid "Given A * B * C, if A and C are on a line r then so is B"
msgstr ""

#: Game.TheoremDoc
msgid "Given A * B * C, if A and B are on a line r then so is C"
msgstr ""

#: Game.TheoremDoc
msgid "Given three points A B C such that A * B * C, the first one is in the line through the others."
msgstr ""

#: Game.TheoremDoc
msgid "Given three points A B C such that A * B * C, the second one is in the line through the others."
msgstr ""

#: Game.TheoremDoc
msgid "Given three points A B C such that A * B * C, the third one is in the line through the others."
msgstr ""

#: Game.TheoremDoc
msgid "If the segment $PQ$ is on the same side of a line $\\ell$, then $P \\notin ‚Ñì$."
msgstr ""

#: Game.TheoremDoc
msgid "If the segment $PQ$ is on the same side of a line $\\ell$, then $Q \\notin ‚Ñì$."
msgstr ""

#: Game.TheoremDoc
msgid "Given three distinct points, they are on the same line if and only if they are collinear."
msgstr ""

#: Game.TheoremDoc
msgid "A is at the same side as A of ‚Ñì."
msgstr ""

#: Game.TheoremDoc
msgid "A is at the same side as B of ‚Ñì if and only if B is at the same side of A of ‚Ñì."
msgstr ""

#: Game.TheoremDoc
msgid "If two points A and C are not on the same side of the line ‚Ñì, there exists a point in the segment A¬∑C which is incident with the line ‚Ñì."
msgstr ""

#: Game.TheoremDoc
msgid "Given lines $m$ and $\\ell$ and a point $A$ in $m$ and not in $\\ell$, there\n"
"exists a point $E$ not in $m$ on the same side of $\\ell$ as $A$."
msgstr ""

#: Game.TheoremDoc
msgid "Given three non-collinear points A, B and C, then B is not incident with the line through A and C."
msgstr ""

#: Game.TheoremDoc
msgid "Given three non-collinear points A, B and C, then A ‚â† C."
msgstr ""

#: Game.TheoremDoc
msgid "Given three non-collinear points A, B, C and a line ‚Ñì, if A and B are on the same side of\n"
"‚Ñì and B and C are on the same side of ‚Ñì, then A and C are on the same side of ‚Ñì."
msgstr ""

#: Game.TheoremDoc
msgid "Given three collinear points A, B, C and a line ‚Ñì, if A and B are on the same side of\n"
"‚Ñì and B and C are on the same side of ‚Ñì, then A and C are on the same side of ‚Ñì."
msgstr ""

#: Game.Levels.TutorialWorld.L00assumption
msgid "The assumption tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L00assumption
msgid "The first tactic that we'll learn is the `assumption` tactic. This can be used\n"
"when your goal is exactly one of your hypotheses. In the following example,\n"
"there are three hypotheses, namely the fact that $A = B$ (hypothesis `h‚ÇÅ`), the\n"
"fact that $C = D$ (hypothesis `h‚ÇÇ`) and the fact that $B = C$ (hypothesis `h‚ÇÉ`).\n"
"\n"
"Since we want to prove that $C = D$, which is one of our hypotheses, we should be able to\n"
"win by typing `assumption,` (**don't forget the comma**). Delete the `sorry` and try it.\n"
"\n"
"**Pro tip:** If the hypothesis to be used is called, say `hb`, you can also close the goal\n"
"by using `exact hb,` instead. Sometimes it is more efficient to do so, especially if we believe\n"
"that assumption should work and we don't know why. The `exact` tactic will give us information\n"
"about why that does not work."
msgstr ""

#: Game.Levels.TutorialWorld.L00assumption
msgid "If $A = B$, $C = D$ and $B = C$, then $C = D$."
msgstr ""

#: Game.Levels.TutorialWorld.L00assumption
msgid "Type 'assumption' and you will be done with this level!"
msgstr ""

#: Game.Levels.TutorialWorld.L00assumption
msgid "Great! Now let's move on to the next level..."
msgstr ""

#: Game.Levels.TutorialWorld.L01rw
msgid "The `rw` (rewrite) tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L01rw
msgid "The next tactic in our list is `rw` (from rewrite). Rewriting is one of the most basic methods of proof,\n"
"where we 'substitute' one object that we know that is equal to another.\n"
"\n"
"For example, if `h : A = B` is a hypothesis (i.e., a proof of `A = B`) in your local context (the box in the top right)\n"
"and if your goal contains one or more `A`s, then `rw h` will change them all to `B`'s.\n"
"\n"
"Now, take a look in the top right box at what we have. The variables `A`, `B` and `C` are\n"
"points that lie in the plane `Œ©`. Here we have to prove that if the point $A$ is equal to the point $B$,\n"
"and the point $B$ is equal to the point $C$, then the point $A$ is equal to the point $C$.\n"
"\n"
"Try to use a sequence of rewrite steps to prove the lemma below by typing them into the box underneath."
msgstr ""

#: Game.Levels.TutorialWorld.L01rw
msgid "If A, B and C are points with A = B and B = C, then A = C."
msgstr ""

#: Game.Levels.TutorialWorld.L01rw
msgid "# Exploring your proof\n"
"\n"
"Click on `rw [h1]`, and then use the arrow keys to move your cursor around the proof.\n"
"Go up and down and note that the goal changes -- indeed you can inspect Lean's 'state' at\n"
"each line of the proof (the hypotheses, and the goal). Try to figure out the exact place\n"
"where the goal changes."
msgstr ""

#: Game.Levels.TutorialWorld.L02rwbis
msgid "The `rw` (rewrite) tactic (II)"
msgstr ""

#: Game.Levels.TutorialWorld.L02rwbis
msgid "## The rewrite (`rw`) tactic (II).\n"
"\n"
"In the previous level, we learned that `rw h` changes A's into B's when the goal contains one or more A's\n"
"and we have the hypothesis `h : A = B` in the local context. You may be wondering if the opposite case is\n"
"also possible. That is to say: could we change B's into A's when the goal contains one or more B's and we have\n"
"the hypothesis `h : A = B` in the local context?\n"
"\n"
"So the answer is... Yes! The hypotheses in this level are a bit different than before,\n"
"so you should use **`rw ‚Üê`** instead. To do so, you can type the little left-arrow by typing **\\l**\n"
"and then a space, so the system will change it automatically."
msgstr ""

#: Game.Levels.TutorialWorld.L02rwbis
msgid "If A, B and C are points with B = A and B = C, then A = C."
msgstr ""

#: Game.Levels.TutorialWorld.L02rwbis
msgid "Good job!"
msgstr ""

#: Game.Levels.TutorialWorld.L03exact
msgid "The `exact` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L03exact
msgid "# Tutorial World\n"
"\n"
"## The `exact` tactic.\n"
"\n"
"In this level, we learn the `exact` tactic, which solves a goal that is exactly one of the hypotheses.\n"
"For example, if the finishing goal is ‚ä¢ `A = B` and we have the hypothesis `z : A = B`, then `exact z`\n"
"will complete the level.\n"
"\n"
"This level is a new variant of the the previous one, but we will solve it in a different way. As you can imagine,\n"
"mathematical proofs can be solved in many differents ways, which is something that definitely makes this field special."
msgstr ""

#: Game.Levels.TutorialWorld.L03exact
msgid "If A, B and C are points with A = B and B = C, then A = C."
msgstr ""

#: Game.Levels.TutorialWorld.L03exact
msgid "Great!"
msgstr ""

#: Game.Levels.TutorialWorld.L05usage
msgid "Using theorems"
msgstr ""

#: Game.Levels.TutorialWorld.L05usage
msgid "You will see that two new theorems have been added to the *Theorems* list:\n"
"\n"
"* line_through_left (P Q : Œ©) : P ‚àà (line_through P Q)\n"
"\n"
"* line_through_right (P Q : Œ©) : Q ‚àà (line_through P Q)\n"
"\n"
"**Note the name of the two statements**. Mathematicians sometimes call them 'Lemma 2.1' or 'Hypothesis P6' or something. But\n"
"computer scientists call them `line_through_left` and `line_through_right` because they are easier to use and remember. From now on,\n"
"all the statements that appear on this list will be remembered by the computer. In this way, we won't have to provide their proofs again.\n"
"Instead, we will use them straightforwardly in case they are handy for solving the following levels.\n"
"\n"
"Just after the name of the statements, two parentheses appear. Inside them, there are the exact number of variables that are needed to\n"
"put out that statements. Then, the colon `:` symbol introduces the statement as such. In this case, they are very similar to each other.\n"
"What they come to mean is that we can draw a line that passes through two distinct points (P and Q) that lie in a plane (Œ©). They symbol `‚àà`\n"
"is read as *is an element of*. Then, P and Q are elements of the line that passes through the points P and Q. Seems obvious, right? Now, let's\n"
"try to solve this level!\n"
"\n"
"Looking at the goal, you will see the same structure as\n"
"the statement `line_through_right (P Q : Point) : Q ‚àà (line_through P Q)`.\n"
"Then, we just have to write that statement in a different way!\n"
"Do you remember that the `exact`\n"
"tactic solved the goal by using a hypothesis of the same structure? Then, because the computer already knows what\n"
"`line_through_right (P Q : Point) : Q ‚àà (line_through P Q)` means, why don't we type `exact line_through_right A B`?\n"
"Type that and see\n"
"how it finishes the proof!"
msgstr ""

#: Game.Levels.TutorialWorld.L05usage
msgid "A point lies in the line that passes through it."
msgstr ""

#: Game.Levels.TutorialWorld.L05usage
msgid "Well done!"
msgstr ""

#: Game.Levels.TutorialWorld.L06intro
msgid "Intro(ducing) hypotheses"
msgstr ""

#: Game.Levels.TutorialWorld.L06intro
msgid "This level introduces the `intro` tactic. This allows you to create\n"
"a new hypothesis in the local context, just above the goal with the `‚ä¢` symbol, whenever you see\n"
"the `‚Üí` symbol in the 'goal' section. [**Remember:** the `‚Üí` symbol refers to the idea of\n"
"an **implication**. `P ‚Üí Q` is read as 'P implies Q' and interpreted as 'If P happens, then Q also happens'.]\n"
"In Lean, if we have the goal `‚ä¢ IT RAINS ‚Üí I GET WET`, by typing `intro h` we will get a new hypothesis in\n"
"the local context of the type `h : IT RAINS` and the goal will just change into  `‚ä¢ I GET WET`.\n"
"\n"
"To solve this level, you will need to use a theorem that has been added to the list of *Theorems*.\n"
"Its name is `incidence`, you can see what it does by clicking on it.\n"
"\n"
"\n"
"**Pro tip:** instead of writing\n"
"several lines of code with the `intro` tactic, you can put them all together. This will make the computer understand\n"
"that you want to create more than one hypothesis at the same time. For example, if you type `intro h1 h2 h3 h4,`, four\n"
"new hypotheses will be added to your local context. Once you've added all the possible hypotheses to it, try to compare\n"
"the goal with the `incidence` statement. Did you notice that we can `rewrite` that statement? Because we have the first\n"
"three **hypotheses** of the statement, we can change the line `r` into `line_through A B`! Type `rw incidence h1 h2 h4` and\n"
"see how the goal changes. To close the goal, try to apply the same argument to the line `s`."
msgstr ""

#: Game.Levels.TutorialWorld.L06intro
msgid "If two lines contain two distinct points, then they are the same line."
msgstr ""

#: Game.Levels.TutorialWorld.L07constructor
msgid "The constructor tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L07constructor
msgid "In this level we will learn the `constructor` tactic. It breaks a goal of the type `P ‚àß Q` into two goals (proving `P`, and then proving `Q`),\n"
"and also breaks goals of the form `P ‚Üî Q` into proving each of the implications separately. That is to say, it asks us to prove `P ‚Üí Q` first, and\n"
"then `Q ‚Üí P`. In mathematics and logic, the **‚àß** symbol is read as **and**. For example, `IT RAINS ‚àß I AM IN THE STREET ‚Üí I OPEN THE UMBRELLA`.\n"
"Analogously, the **`‚Üî`** symbol refers to a **double implication**, or an **if and only if** statement. In written mathematics, you could also\n"
"find the **`‚Üî`** symbol written as **iff**.\n"
"\n"
"You should be able to solve this level on your own. You can solve it in three lines of code."
msgstr ""

#: Game.Levels.TutorialWorld.L07constructor
msgid "If two lines contain two distinct points, then they are the same line."
msgstr ""

#: Game.Levels.TutorialWorld.L08have
msgid "The have tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L08have
msgid "In this level, we introduce the new tactic `have`. It is used to add a new hypothesis\n"
"to the context (which, of course, you will have to prove!). This is sometimes useful to structure our proofs. In this particular level, it is convenient\n"
"to prove first that `r = line_through B C`, and then that `s = line_through B C`. This strategy will allow us to finish the proof very easily!\n"
"\n"
"To use the tactic `have`, we should follow the following structure: `have h : A = B`. This line will add the hypothesis `h : A = B` to the local\n"
"context and break the proof into two goals. First, Lean will ask us to prove `‚ä¢ A = B` without the hypothesis `h : A = B`. Then, it will ask us to\n"
"prove the goal that existed before using the tactic `have` with the support of the new hypothesis `h : A = B` that we have added to the local context.\n"
"\n"
"**Pro tip:** Because you're getting better at this, proofs are going to be more challenging. Whenever you see that you have to prove two\n"
"or more goals to finsih one level, you may want to use *bullet points* to isolate them. You type them with `\\¬∑`, or if you are lucky to have a Catalan keyboard\n"
"then you can directly enter it (middle dot, press `Shift+3`). After each of these bullet points, you will only see one goal.\n"
"\n"
"For example, the first line of this proof will be `have hr : r = line_through B C` (you can change `hr` into whatever name you are comfortable with to\n"
"make reference to the hypothesis `r = line_through B C`). Now, because two goals have appeared, you can type the following structure:\n"
"\n"
"```\n"
"have hr : r = line_through B C\n"
"¬∑ sorry\n"
"¬∑ sorry\n"
"```\n"
"\n"
"In this way, by deleting the `sorry`'s, you will be able to prove the goals separately. Now, let's try solve this level together so that you can\n"
"easily understand how the syntax of Lean works!\n"
"\n"
"First, we are going to prove the first goal, which is `‚ä¢ r = line_through B C`. To begin with, let's look at the *Theorems* we have.\n"
"Can you note that `incidence` finishes with the same structure as our goal? Then, we have to check if we have the previous implications of `incidence`\n"
"in our local context. On the face of it, `h : B ‚â† C` and `h1 : B ‚àà r ‚àß C ‚àà r` are what we are looking for. However, `h1` should be divided into `B ‚àà r`\n"
"and `C ‚àà r`, right? [**Rule of thumb:** whenever a hypothesis looks like `h1 : P ‚àß Q`, we can refer to `P` and `Q` as `h1.1` and `h1.2`, respectively.]\n"
"Then, notice how `exact incidence h h1.1 h1.2` closes the first goal!\n"
"\n"
"Before jumping onto the second goal, we may want to rewrite something first. Can you see that we can `rw [hr]` (where `hr : r = line_through B C`) to change\n"
"the goal `‚ä¢ r = s` into `‚ä¢ line_through B C = s`. Now, you will be wondering if `exact incidence h h2.1 h2.2,` finishes the proof, but it does not. Do you\n"
"know why? Because the theorem statement called `incidence` works with the goal `‚ä¢ s = line_through B C`, but not with `‚ä¢ line_through B C = s`. Because of\n"
"this reason, we should create another hypothesis by using the `have` tactic. That is to say, type `have hs : s = line_through B C` right before the curly braces."
msgstr ""

#: Game.Levels.TutorialWorld.L08have
msgid "If two lines share two distinct points, then they are the same line."
msgstr ""

#: Game.Levels.TutorialWorld.L08have
msgid "Great! Now on to learning more tactics..."
msgstr ""

#: Game.Levels.TutorialWorld.L09use
msgid "The use tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L09use
msgid "In further proofs, we will need to prove that there exists an object satisfying certain properties.\n"
"The goal will then look like `‚ä¢ ‚àÉ x, P x`, where the symbol `‚àÉ` is read as *there exists* and\n"
"`P x` can be understood as *x satisfies property P*\n"
"In this case, the whole goal can be interpreted as *there exists x satisfying property P*.\n"
"Then, the `use` tactic is useful. If we know that an object `a` satisfies the  property `P`, then `use a`\n"
"will simplify the goal into `‚ä¢ P a`.\n"
"\n"
"In the example below, we are given three points and two lines. We know certain things about the points, and the\n"
"goal is to find a line $\\ell$ such that $P$, $Q$ and $R$ belong to $\\ell$. Think, looking at the hypotheses,\n"
"which line could do the trick. Then `use` it, and finish the proof using tactics you already know."
msgstr ""

#: Game.Levels.TutorialWorld.L09use
msgid "Find a line that contains the point $P$."
msgstr ""

#: Game.Levels.TutorialWorld.L10rcases1and
msgid "The `rcases` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L10rcases1and
msgid "# Advanced Tutorial World\n"
"\n"
"## The `rcases` tactic.\n"
"\n"
"The next tactic we introduce is `cases`, and since it does many things\n"
"we will have a couple levels seeing when to apply it. This tactic works\n"
"always on hypotheses, and it transforms them in different ways. The first\n"
"instance that we learn arises when you have a hypothesis that says that `P`\n"
"and `Q` holds. That is, you have `h : P ‚àß Q`. Then `cases h with h1 h2` will\n"
"replace `h` with two new hypotheses, namely `h1 : P` and `h2 : Q`.\n"
"\n"
"This is done usually for aesthetic reasons, since `h.1` and `h.2` also serve\n"
"as proofs of `P` and `Q`.\n"
"\n"
"Knowing that, I'm sure you can complete this level on your own. It's only two lines of code!"
msgstr ""

#: Game.Levels.TutorialWorld.L10rcases1and
msgid "The line ‚Ñì is the line through P and Q as long as P ‚â† Q and both P and Q are in ‚Ñì."
msgstr ""

#: Game.Levels.TutorialWorld.L11rcases2or
msgid "The `rcases` tactic (II)"
msgstr ""

#: Game.Levels.TutorialWorld.L11rcases2or
msgid "# Advanced Tutorial World\n"
"\n"
"## The `cases` tactic (II).\n"
"\n"
"Suppose now that your hypothesis says that `P` or `Q` holds. That is, you have `h : P ‚à® Q`. Then `cases h` will create\n"
"two new goals, and in each of them it will replace `h` with `h : P` in the first case, and with `h : Q` in the second.\n"
"\n"
"To solve this level, you may need to remember how to employ the `use` tactic. As a reminder, note that if the goal is of\n"
"the form `‚ä¢ ‚àÉ (R : Œ©), R ‚àà ‚Ñì`, then you can type `use X`, where `X` is any object that satisfies $X \\in R$ , so that it\n"
"turns the goal into `‚ä¢ X ‚àà ‚Ñì`. The object you are looking for either is found in the *Theorems* section or in the hypotheses\n"
"right above the goal of this level.\n"
"[**Reminder:** if the goal breaks into two goals, remember that you can use `¬∑` to make\n"
"the look of the proof more visual.]"
msgstr ""

#: Game.Levels.TutorialWorld.L11rcases2or
msgid "If ‚Ñì is any line in the plane Œ© and either the point P or the point Q is in ‚Ñì, then ‚Ñì is not an empty line."
msgstr ""

#: Game.Levels.TutorialWorld.L13simp
msgid "The `simp` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L13simp
msgid "In this level, we introduce a high level tactic called `simp`. This is an Artificial Intelligence (AI) tactic which\n"
"can nail some really tedious-for-a-human-to-solve goals. It uses lemmas that are already in our database to make\n"
"the goal simpler. You can simplify an hypothesis `h` by calling `simp at h,`. As the game progresses, this tactic\n"
"will become better (we are tagging some of the lemmas as *simp lemmas* along the way).\n"
"\n"
"Just to illustrate, **LEAN** has a lemma  (called `not_not`) that says that double negation is the same as an affirmation:\n"
"\n"
"`@[simp] lemma not_not (p : Prop) : ¬¨¬¨ p ‚Üî p`\n"
"\n"
"The fact that it has `@[simp]` written in front of it instructs the `simp` tactic to replace all occurrences\n"
"of `¬¨¬¨ p` with `p`. There are lots of lemmas like these in **LEAN**, which makes this tactic really powerful."
msgstr ""

#: Game.Levels.TutorialWorld.L13simp
msgid "If a point $P$ is on a line $\\ell$, then $P$ is not outside of $\\ell$."
msgstr ""

#: Game.Levels.TutorialWorld.L14tauto
msgid "The `tauto` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.L14tauto
msgid "When the goal follows from the hypotheses directly from the rules of logic, then we say that we are proving a tautology,\n"
"and there is a tactic that does this automatically for us. For example, the following is a tautology (if p, q and r are\n"
"arbitrary statements).\n"
"\n"
"p ‚à® (q ‚àß r) ‚Üî (p ‚à® q) ‚àß (r ‚à® p ‚à® r)\n"
"\n"
"You can see that this is true because regardless of whether each of `p`, `q` and `r` is true or false, the statement\n"
"above is true."
msgstr ""

#: Game.Levels.TutorialWorld.L14tauto
msgid "If $p$, $q$ and $r$ are three true-false statements, and we know $p \\lor q$ and $r \\lor p \\lor r$, then\n"
"we have $p \\lor (q \\land r)$."
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Tutorial World"
msgstr ""

#: Game.Levels.TutorialWorld
msgid "# Tutorial World\n"
"\n"
"## The setup\n"
"\n"
"Welcome to the Tutorial World! In this world, you're going to prove some geometric facts by using **`tactics`**.\n"
"These *tactics* are just instructions that make progress in a mathematical proof.\n"
"During your proofs, your 'goal' (i.e. what you're\n"
"supposed to be proving) will be displayed in front of a `‚ä¢` symbol on the top\n"
"right hand box, so you will need to use *tactics* to close that goals. Once you close all the goals, the top\n"
"right hand box will report 'Proof complete!', so that you\n"
"can move on to the next level in the world you're in.\n"
"\n"
"## The language\n"
"\n"
"In **LEAN**, everything (points, lines, a set of points, a theorem, a proof) is a *term*, and each term is of a certain *type*,\n"
"and only one. One writes `x : T` to say that the term $x$ is of type $T$ (you can read the ':' as 'is an element of'). By the way,\n"
"*types* are themselves terms (rembember, **everything** is a term). For example, a point $P$ will be a term of type $\\Omega$ (which will\n"
"denote the plane). We will write this as `P : Œ©`. The plane $\\Omega$ is of type `Type` (this is a special type, whose terms are\n"
"things like the plane, or the set of the real numbers).\n"
"\n"
"There is also another special type called `Prop`. A term of type `Prop` is a true-false statement, like 'it rains', '2 + 2 = 4',\n"
"'2 + 3 = 7' (yes, they can be either True or False). A term of type '2 + 2 = 4' would be a proof of this fact.\n"
"We will write `h : 2 + 2 = 4` to mean exactly this: `h` is a proof of the fact that `2 + 2 = 4`, and we can use it in our proof.\n"
"If we had `h' : 2 + 3 = 7` then we would probably be able to proof crazy things!"
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Great!"
msgstr ""

#: Game.Levels.IncidenceWorld.level01
msgid "The symmetry of the line through two points"
msgstr ""

#: Game.Levels.IncidenceWorld.level01
msgid "In this level, we introduce the `by_cases` tactic. Mathematicians would use it to provide a *proof by cases*.\n"
"This is useful when we need to split a proof into different cases.\n"
"\n"
"In the proof below there is a `trivial` case that we have to consider, which is the possibility\n"
"that `P = Q`. In If we type `by_cases h : P = Q` we will split the goal into two branches: the first one\n"
"will have the assumption `h : P = Q` in the context, while in the second we will have `h : P ‚â† Q`."
msgstr ""

#: Game.Levels.IncidenceWorld.level01
msgid "The line through two points is a symmetric concept."
msgstr ""

#: Game.Levels.IncidenceWorld.level02
msgid "The `by_contra` tactic"
msgstr ""

#: Game.Levels.IncidenceWorld.level02
msgid "Congratulations! You are about to finish the second world of The Euclid Game!\n"
"In this level, we introduce the `by_contra` tactic. Mathematicians would use\n"
"it to provide a **proof by contradiction**. This tactic changes the goal from\n"
"`‚ä¢ P` to `‚ä¢ false` and adds a new hypothesis of the form `h : ¬¨ P` to the local context.\n"
"\n"
"To finish this world, we would like to prove that two distinct lines have **at most**\n"
"one point in common. Delete the `sorry` to see the goal appear as `‚ä¢ A = B`. Now, take a look\n"
"to the hypotheses that we have in our local context and try to do a drawing of the situation\n"
"by using all of them. Once you're done, note that the points A and B must be equal so that the\n"
"lines r and s satisfy the hypothesis `hrs: r ‚â† s`. Then, try to look for a theorem statement which\n"
"could be useful for this level. As you've well deduced, `equal_lines_of_contain_two_points`\n"
"is the right path to choose. However, note that it states `A ‚â† B` and `r = s` instead of `A = B`and\n"
"`r ‚â† s`, respectively. Because of this reason, the `by_contra` tactic has to join the party.\n"
"\n"
"Now, try to solve this level on your own in just three lines of code. [**Remember:** whenever you see\n"
"a hypothesis of the form `h : P ‚â† Q`, Lean can also understand it as `h : ¬¨ (P = Q)`, or `h : (P = Q) ‚Üí false`.]"
msgstr ""

#: Game.Levels.IncidenceWorld.level02
msgid "Two distinct lines have at most one point in common."
msgstr ""

#: Game.Levels.IncidenceWorld.level03
msgid "Lines are thin"
msgstr ""

#: Game.Levels.IncidenceWorld.level03
msgid "We start by proving that every line misses at least one point. Note that, although this seems obvious,\n"
"it is not directly one of our axioms, and thus we must prove it from them.\n"
"\n"
"This lemma uses in a crucial way the fact that we have three distinc non-collinear points. Remember that\n"
"the axiom which guarantees this is called `existence` and is formalized as\n"
"`existence Œ© : ‚àÉ A B C : Œ©, A ‚â† B ‚àß A ‚â† C ‚àß B ‚â† C ‚àß ...`\n"
"\n"
"To use this axiom, the very versatile `rcases` tactic comes to help us again. If we type `rcases existence Œ©`\n"
"we will see all the new variables (A, B, C, ...) appearing in our context. We can name them for later usage,\n"
"using the syntax\n"
"`rcases existence Œ© with ‚ü®A, B, C, ‚ü®hAB, hAC, hBC, h‚ü©‚ü©`.\n"
"\n"
"In general, if we have a theorem `h` that says `‚àÉ x y, P x y ‚àß Q x y`, we will extract it with\n"
"`rcases h with ‚ü®x, y, ‚ü®hP, hQ‚ü©‚ü©`."
msgstr ""

#: Game.Levels.IncidenceWorld.level03
msgid "Every line misses at least one point."
msgstr ""

#: Game.Levels.IncidenceWorld.level04
msgid "Lines are thin"
msgstr ""

#: Game.Levels.IncidenceWorld.level04
msgid "## Proving useful lemmas (I).\n"
"\n"
"To solve this level, you will need to use the second axiom of incidence."
msgstr ""

#: Game.Levels.IncidenceWorld.level04
msgid "Given a line, there exists one point on that line."
msgstr ""

#: Game.Levels.IncidenceWorld.level05
msgid "A point to show that two lines are different"
msgstr ""

#: Game.Levels.IncidenceWorld.level05
msgid "## A useful lemma\n"
"\n"
"We will see that\n"
"a point can help us deciding that two lines are different.\n"
"\n"
"To solve this level, you just need three lines of code. Try to finish it on your own."
msgstr ""

#: Game.Levels.IncidenceWorld.level05
msgid "If two lines `r` and `s` do not share a point, then they are not equal."
msgstr ""

#: Game.Levels.IncidenceWorld.level06
msgid "A line-avoiding point"
msgstr ""

#: Game.Levels.IncidenceWorld.level06
msgid "In this level we prove that given two different lines, there is a point in the first line that is not in the second.\n"
"\n"
"Here is a possible plan of the proof, to help you get started. Make sure you have\n"
"all the details written down in paper before you start typing!\n"
"\n"
"*Proof sketch:*\n"
"\n"
"1. Consider two points $A$ and $B$ on the line $r$.\n"
"2. Do a proof by cases:\n"
"  - If $A \\notin s$, then there is nothing to do, $A$ is the sought point.\n"
"  - If $A \\in s$, then show that $B \\notin s$, and $B$ is the sought point."
msgstr ""

#: Game.Levels.IncidenceWorld.level06
msgid "If two lines are different, there is a point in one that is not in the other"
msgstr ""

#: Game.Levels.IncidenceWorld.level07
msgid "Triangles"
msgstr ""

#: Game.Levels.IncidenceWorld.level07
msgid "We end this world by proving the existence of triangles. We will also make use of convenient tactic,\n"
"which is called `apply`. Suppose you are asked to prove a goal of the form `‚ä¢ R` and you have a theorem statement called `h` which\n"
"ensures that `h : P ‚Üí Q ‚Üí R`. Then, `apply h` will change your goal into proving `‚ä¢ Q` and `‚ä¢ P`.\n"
"\n"
"To give you some hints, remember these Lean tips that might help you to step through the proof.\n"
"\n"
"**Tip 1:** whenever a hypothesis looks like `h : P ‚àß Q`, we can refer to `P` and `Q` as `h.1` and `h.2`, respectively.\n"
"\n"
"**Tip 2:** whenever you have a goal of the form `‚ä¢ ‚àÄ (P : Œ©), ...`, the `intro` tactic will make progress.\n"
"\n"
"If needed, you can go back to the previous levels to remember how to use some tactics. Good luck! Let's do this!"
msgstr ""

#: Game.Levels.IncidenceWorld.level07
msgid "There exist three lines that do not have a point in common."
msgstr ""

#: Game.Levels.IncidenceWorld.level07
msgid "Great! Now you are ready to study a new set of axioms!"
msgstr ""

#: Game.Levels.IncidenceWorld
msgid "Incidence World"
msgstr ""

#: Game.Levels.IncidenceWorld
msgid "In mathematics, we need to set down some starting points\n"
"to build our knowledge, and this is why axioms should join the game. What are axioms, then?\n"
"They are unprovable statements which are assumed to be true *because of their self-evidence*.\n"
"They serve as a premise for further reasoning and arguments, so that we can reach new conclusions from them.\n"
"\n"
"By travelling back in time to 300 B.C., we meet the great mathematician Euclid, who suggested the very\n"
"first postulates of geometry in his well-known book **Elements**. Euclidean geometry can be built up from three\n"
"sets of axioms, each of them adding new independent notions that are needed to define the plane. These sets of axioms\n"
"were proposed by David Hilbert (1862-1943 AD), who made remarkable improvements in the foundations of geometry.\n"
"These three blocks of axioms are called **incidence**, **order** and **congruence** (we might also want to add the **parallel axiom**,\n"
"but that would come later).\n"
"\n"
"In this world we concentrate on the first block, the axioms of **incidence**. There are three axioms of incidence, that\n"
"will give the relationships between the primitive notions of\n"
"**point** and **line**. Notice\n"
"that by *incidence* we mean whatever idea that satifies the axioms of incidence. Then, you will be wondering... are the\n"
"notions of *point* and *line* referring to whatever object of reality that satisfies the axioms of incidence? Exactly!\n"
"Before the axioms of incidence, these notions are **undefined**!\n"
"\n"
"Let's then introduce the axioms of incidence:\n"
"\n"
"**A.1)** For every point $P$ and for every point $Q$ not equal to $P$, there exists a unique line $\\ell$\n"
"*passing through* (= incident with) $P$ and $Q$.\n"
"\n"
"![Axiom A.1](axiomA1.png *First  axiom of incidence*)\n"
"\n"
"**A.2)** For every line $\\ell$, there exist two distinct points that belong to it.\n"
"\n"
"![Axiom A.2](axiomA2.png &Second axiom of incidence*)\n"
"\n"
"**A.3)** There exist three distinct points with the property that no line *passes through* (= is incident with) all three of them.\n"
"\n"
"![Axiom A.3](axiomA3.png *Third axiom of incidence*)\n"
"\n"
"The drawings above may help you understand (or remember) each of the axioms, but they\n"
"have no meaning in mathematics. We will not be able to use them in our proofs!\n"
"\n"
"## The axioms of incidence in Lean.\n"
"\n"
"How do we make the computer understand such complex statements? We use the **LEAN** language! However,\n"
"it is easier to divide some of them into more than one statements. In this case, we have\n"
"the following four axioms:\n"
"\n"
"* `line_through (P Q : Œ©) : Line Œ©`\n"
"\n"
"This produces, given two points, a certain line through them. Think of it as a function that eats\n"
"two points $P$ and $Q$ and outputs a line $\\ell$ called `line_through P Q`.\n"
"\n"
"* `line_through_left (P Q : Œ©) : P ‚àà (line_through P Q)`\n"
"\n"
"* `line_through_right (P Q : Œ©) : Q ‚àà (line_through P Q)`\n"
"\n"
"These two statements guarantee that the line `line_through P Q` does indeed contain both $P$ and $Q$.\n"
"The next statement is about uniqueness, and here we need to ask that $P \\neq Q$. We know that there\n"
"is a line through $P$ and $Q$, namely `line_through P Q`. The `incidence` statement says that if a\n"
"line $\\ell$ is so that $P$ and $Q$ are both in $\\ell$, then this line $\\ell$ must be `line_through P Q`.\n"
"\n"
"* `incidence {P Q : Œ©} {‚Ñì : Line Œ©} : P ‚â† Q ‚Üí P ‚àà ‚Ñì ‚Üí Q ‚àà ‚Ñì ‚Üí ‚Ñì = line_through P Q`\n"
"\n"
"The second axiom of incidence is quite straightforward in **LEAN**:\n"
"\n"
"* `line_contains_two_points (‚Ñì : Line Œ©) : ‚àÉ P Q : Œ©, P ‚â† Q ‚àß ‚Ñì = line_through P Q`\n"
"\n"
"The third axiom also translates rather easily. In order to state that the three points are\n"
"non-collinear, we say that the third point $R$ does not lie in the (unique) line through $P$ and $Q$.\n"
"\n"
"* `existence (Œ© : Type) : ‚àÉ P Q R : Œ©, P ‚â† Q ‚àß P ‚â† R ‚àß Q ‚â† R ‚àß R ‚àâ (line_through P Q)`\n"
"\n"
"Let's get started!"
msgstr ""

#: Game.Levels.BetweennessWorld.level01
msgid "Ordering matters"
msgstr ""

#: Game.Levels.BetweennessWorld.level01
msgid "To solve this level, you will need to use two axioms of order.\n"
"You will notice that he list of theorems has been expanded. Take a look at the new\n"
"theorems and try to think of a mathematical proof in paper before typing your solution in Lean."
msgstr ""

#: Game.Levels.BetweennessWorld.level01
msgid "Given three distinct collinear points A, B and C, if B lies between A and C, then A does not lie between B and C."
msgstr ""

#: Game.Levels.BetweennessWorld.level02
msgid "Don't try to break a point into two..."
msgstr ""

#: Game.Levels.BetweennessWorld.level02
msgid "In this level, we are asked to show that points cannot be splitted.\n"
"You may want to use the first axiom of order `different_of_between_??`,\n"
"there are three variations you can use which you can find in the list of *Theorems*."
msgstr ""

#: Game.Levels.BetweennessWorld.level02
msgid "There are no points between a point and itself."
msgstr ""

#: Game.Levels.BetweennessWorld.level03
msgid "Points that are in between of each other share a line"
msgstr ""

#: Game.Levels.BetweennessWorld.level03
msgid "To solve this level, the mathematical proof in paper will be given to you. Remember that you can use theorem statements from previous worlds.\n"
"\n"
"**Claim:** A point that lies between two different points shares the same line with them.\n"
"\n"
"**Proof:** Let $B$ be the point that lies between $A$ and $C$, where these two are different points that lie on the line `r`.\n"
"\n"
"**(i)** Observe first that there is a line, say $s$, containing $A$, $B$, and $C$: by the first axiom of order\n"
"`collinear_of_between`, since $A * B * C$, we can obtain it.\n"
"\n"
"**(ii)** Note that $A\\neq C$. In fact if we had $A = C$, then $A * B * C$ would be equal to $C * B * C$. By the lemma `no_point_between_a_point`, this is\n"
"not possible, so we prove that $A \\neq C$.\n"
"\n"
"**(iii)** Finally, we can prove that $r = s$, by using the lemma `equal_lines_of_contain_two_points`.\n"
"Therefore, $B \\in s$, which we proved in **(i)**, must be equivalent to $B \\in r$. Therefore, the point $B$ shares the same line $r$ with the points\n"
"$A$ and $C$, and we are done."
msgstr ""

#: Game.Levels.BetweennessWorld.level04
msgid "Another version of the previous level"
msgstr ""

#: Game.Levels.BetweennessWorld.level04
msgid "You can try this variation of the previous lemma on your own.\n"
"Remember that it's best to have a paper proof before you start typing!"
msgstr ""

#: Game.Levels.BetweennessWorld.level04
msgid "Given two different collinear points A and B, there is a third C that shares the same line with them and satisfies A * B * C."
msgstr ""

#: Game.Levels.BetweennessWorld.level05
msgid "Another version of the previous level"
msgstr ""

#: Game.Levels.BetweennessWorld.level05
msgid "This version may also be useful later"
msgstr ""

#: Game.Levels.BetweennessWorld.level05
msgid "Given three points A B C such that A * B * C, the third one is in the line through the others."
msgstr ""

#: Game.Levels.BetweennessWorld.level05
msgid "Now on to the next level! We will add for you variations of this one that are proved in\n"
"a very similar way."
msgstr ""

#: Game.Levels.BetweennessWorld.level06
msgid "Between knows no sides"
msgstr ""

#: Game.Levels.BetweennessWorld.level06
msgid "In order to prove this variation, we will practice the use of  another axiom, namely the fact that\n"
"A * B * C ‚Üî C * B * A. This axiom is known as `between_symmetric`, and if you `rw` it at the\n"
"beginning of the next proof then you will be able to reduce to the previous version of the lemma.\n"
" fact hta t"
msgstr ""

#: Game.Levels.BetweennessWorld.level06
msgid "Now on to the next level! We will add for you variations of this one that are proved in\n"
"a very similar way."
msgstr ""

#: Game.Levels.BetweennessWorld.level07
msgid "The `point_on_ray` axiom"
msgstr ""

#: Game.Levels.BetweennessWorld.level07
msgid "In this level we will practice using another axiom of Betweenness, namely the `point_on_ray`. This says\n"
"that given two distinct points A, B, there exists a third point C such that A * B * C. You will have\n"
"to apply it twice to get the two points sought in this level."
msgstr ""

#: Game.Levels.BetweennessWorld.level07
msgid "Given two distinct points A, B, there exist points C, D such that A * B * C* and B * C * D."
msgstr ""

#: Game.Levels.BetweennessWorld
msgid "Betweenness World"
msgstr ""

#: Game.Levels.BetweennessWorld
msgid "## The axioms of order\n"
"\n"
"Also called the axioms of betweenness, the axioms of order were formalized by David Hilbert (1862-1943 AD) on the occasion of studying the Euclid's `Elements`.\n"
"When it comes to them, there are up to four axioms of order. Their learning involves the definition of **segment**, **betweenness**, **line separation** and\n"
"**plane separation**, among others. In written mathematics, the notion of **betweenness** is represented by the **`*`** symbol. Now, let's take a look at the axioms of order.\n"
"\n"
"**B.1)** If $A ‚àó B ‚àó C$, then $A$, $B$, $C$ are three distinct points all lying on the same line, and $C ‚àó B ‚àó A$.\n"
"\n"
"**B.2)** Given two distinct collinear points $A$ and $B$, there is a third point $C$ such that $A * B * C$.\n"
"\n"
"**B.3)** Given 3 distinct collinear points $A$, $B$ and $C$, exactly one of them is between the other two.\n"
"\n"
"**B.4)** [This axiom will be learned in the following world.]\n"
"\n"
"Later on this world we will learn the definition of **segment**, which can be inferred from the first three axioms of order.\n"
"\n"
"## The axioms of order in Lean\n"
"\n"
"To solve the levels of this world, we may need to use the first three axioms of order, so below\n"
"you have them in Lean format.\n"
"\n"
"The first axiom of order is divided into three statements:\n"
"\n"
"* `between_symmetric {A B C : Œ©} : (A * B * C) ‚Üî (C * B * A)`\n"
"\n"
"* `different_of_between {A B C : Œ©} : (A * B * C) ‚Üí (A ‚â† B ‚àß A ‚â† C ‚àß B ‚â† C)`\n"
"\n"
"* `collinear_of_between {A B C : Œ©} : (A * B * C) ‚Üí ‚àÉ ‚Ñì : Line Œ©, A ‚àà ‚Ñì ‚àß B ‚àà ‚Ñì ‚àß C ‚àà ‚Ñì`\n"
"\n"
"The second axiom of order is represented as follows:\n"
"\n"
"* `point_on_ray {A B : Œ©} (h: A ‚â† B) : ‚àÉ (C : Œ©), A * B * C`\n"
"\n"
"The third axiom of order is a bit long to spell out in Lean:\n"
"\n"
"* `between_of_collinear {A B C : Œ©} (h: ‚àÉ(‚Ñì : Line Œ©), A ‚àà ‚Ñì ‚àß B ‚àà ‚Ñì ‚àß C ‚àà ‚Ñì) :\n"
"	  ((A * B * C) ‚àß ¬¨ ( B * A * C ) ‚àß ¬¨ (A * C * B)) ‚à®\n"
"	  (¬¨ (A * B * C) ‚àß ( B * A * C ) ‚àß ¬¨ (A * C * B)) ‚à®\n"
"	  (¬¨ (A * B * C) ‚àß ¬¨ ( B * A * C ) ‚àß (A * C * B))`"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level01
msgid "Same side"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level01
msgid "Thanks to the Pash axiom we can define what *being on the same side* means.\n"
"\n"
"**Definition:** Given a line ‚Ñì and the points A and B, such that A, B ‚àâ ‚Ñì, we say that A and B are on the same side if\n"
"the segment A¬∑B does not meet ‚Ñì or A = B.\n"
"\n"
"In Lean, the definition of `same_side` is represented as follows:\n"
"\n"
"* `def same_side (‚Ñì : Line Œ©) (P Q : Œ©) :=  P ‚àâ ‚Ñì ‚àß Q ‚àâ ‚Ñì ‚àß (‚àÄ x, (P * x * Q) ‚Üí x ‚àâ ‚Ñì)`\n"
"\n"
"\n"
"[**Rule of thumb:** Whenever you see `same_side` in Lean, you may use the `rw` tactic to unfold its definition. In this way, it will be easier to understand what it means. If it is\n"
"located at the hypothesis `h2`, for example, then `rw [same_side] at h2` will make progress. If it is located at the goal, then `rw [same_side]` will be enough\n"
"to rewrite the goal.\n"
"\n"
"As a bonus, we have added a useful lemma (you could prove it easily at this stage, we\n"
"are just saving you some time) that allows to change the order of the points that\n"
"appear in a collinearity statement\n"
"\n"
"* `lemma collinear_of_equal (A B C D E F)\n"
"  ({A, B, C} = {D, E, F}) ‚Üí collinear A B C ‚Üî collinear D E F`\n"
"\n"
"Lean will help you by filling in the proof of the two sets being equal, when this is trivially true."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level01
msgid "If the segment $PQ$ is on the same side of a line $\\ell$, then $P \\notin ‚Ñì$."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level02
msgid "A useful rewrite"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level02
msgid "To solve the following levels it will be useful to have the following criterion for collinearity.\n"
"Here you have some hints that could help you to step through it!\n"
"\n"
"**Hint 1:** Whenever you see the word `collinear`, the `rw` tactic will make progress.\n"
"\n"
"**Hint 2:** Whenever you find a goal or hypothesis of the form `‚àÄ {X : Œ©}, X ‚àà {A, B, C} ‚Üí X ‚àà r`, the `simp` tactic will make progress.\n"
"\n"
"**Hint 3:** To solve the first goal, you may want to use the theorem statement `incidence` with the `rw` tactic."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level02
msgid "Given three distinct points, they are on the same line if and only if they are collinear."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level03
msgid "Reflexivity"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level03
msgid "In this (easy!) level we prove that a point outside a line is on the same side of the line as itself.\n"
"It seems stupid, but needs to be proven nevertheless."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level03
msgid "A is at the same side as A of ‚Ñì."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level04
msgid "Who is on the same side?"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level04
msgid "In this level we prove that being on the same side of a line is a symmetric concept. We only\n"
"ask you to prove one implication, the double implication is done in the same way and it will\n"
"be given to you for free in the Theorem list."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level04
msgid "A is at the same side as B of ‚Ñì if and only if B is at the same side of A of ‚Ñì."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level05
msgid "On the way to the final level (I)"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level05
msgid "Welcome to the last trip of The Euclid Game! This is the first of five lemmas that we need to prove before jumping into the final level of the game! You will be provided with\n"
"their mathematical proof in paper so as to solve them with ease. Remember to read the lemma and do a drawing of the situation. Let's get started!\n"
"\n"
"## Mathematical proof in paper...\n"
"\n"
"**Claim:** Given three non-collinear points A, B and C, then A ‚â† C.\n"
"\n"
"**Proof:**\n"
"\n"
"Let us assume that `A ‚â† C`. That is, `(A = C) ‚Üí false`. Then, let us assume that `A = C`. Now, we want to prove that this is false.\n"
"We know that A, B, C are non-collinear. That is, `collinear {A, C, B} ‚Üí false`. Then, it suffices to prove that A, B, C are collinear points.\n"
"Because `A = C`, then `collinear {A, C, B} = collinear {C, C, B}`. For this reason, there has to exist a line ‚Ñì and a point P, such that `P ‚àà {C, C, B} ‚Üí P ‚àà ‚Ñì`.\n"
"Let the line ‚Ñì be the line through B and C. Then, `P ‚àà line_through B C`. Because `P ‚àà {C, C, B}`, then either P = C or P = B. If P = C, then\n"
"`(P ‚àà line_through B C) = (C ‚àà line_through B C)`. By the first axiom of incidence (`line_through_right`), we prove that `C ‚àà line_through B C`.\n"
"If P = B, then `(P ‚àà line_through B C) = (B ‚àà line_through B C)`. By the first axiom of incidence (`line_through_left`), we prove that `B ‚àà line_through B C`."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level05
msgid "Given three non-collinear points A, B and C, then A ‚â† C."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level06
msgid "On the way to the final level (II)"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level06
msgid "This is the second of five lemmas that we need to prove before jumping into the final level of the game! You will be provided with\n"
"its mathematical proof in paper right below. Remember that you can use all the theorem statements from the left-hand side box.\n"
"\n"
"## Mathematical proof in paper...\n"
"\n"
"**Claim:** Given three non-collinear points A, B and C, then B is not incident with the line through A and C.\n"
"\n"
"**Proof:**\n"
"\n"
"By the lemma `noncollinear_ne_points`, since A, B and C are non-collinear points, then `A ‚â† C`.\n"
"\n"
"By the lemma `collinear_iff_on_line_through`, since `A ‚â† C`, then it suffices to prove that the points A, C, B are not collinear.\n"
"\n"
"By the assumption of the lemma `hCol : ¬¨ collinear ({A, C, B} : set Œ©))`, then we show that `B ‚àâ line_through A C`."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level06
msgid "Given three non-collinear points A, B and C, then B is not incident with the line through A and C."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level07
msgid "On the way to the final level (IV)"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level07
msgid "This is the fourth and last lemma that we need to prove before jumping into the final level of the game!"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level07
msgid "If two points A and C are not on the same side of the line ‚Ñì, there exists a point in the segment A¬∑C which is incident with the line ‚Ñì."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level08
msgid "The Pasch Axiom in action!"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level08
msgid "In this level we prove transitivity of the relation *being in the same side of $\\ell$*, provided that the three\n"
"points involved are non-collinear. So suppose that we are given three non-collinear points $A$, $B$, $C$, and suppose\n"
"that $A$ is on the same side of $\\ell$ as $B$, and $B$ is on the same side of $\\ell$ as $C$. We want to prove that $A$ is on\n"
"the same side of $\\ell$ as $C. Here is a sketch of the proof.\n"
"\n"
"1. We argue by contradiction, so assume that the line $AC$ does meet $\\ell$.\n"
"2. Let $D \\in \\ell$ be the point of intersection, so $A * D * C$.\n"
"3. Use Pasch to prove that either $\\ell$ either meets the segment $AB$ or $BC$, thus\n"
"  obtaining a contradiction.\n"
"\n"
"This is the first time that we will use Pasch's axiom. Remember what it says:\n"
"\n"
"`\n"
"pasch {A B C D : Œ©} {‚Ñì : Line Œ©} (hnc : C ‚àâ line_through A B)\n"
"(hnAl : A ‚àâ ‚Ñì) (hnBl : B ‚àâ ‚Ñì) (hnCl : C ‚àâ ‚Ñì) (hDl : D ‚àà ‚Ñì) (hADB : A*D*B) :\n"
"  (same_side ‚Ñì A C ‚àß ¬¨same_side ‚Ñì C B) ‚à® (¬¨same_side ‚Ñì A C ‚àß same_side ‚Ñì C B)\n"
"`\n"
"\n"
"![Proof sketch](trans_noncollinear_diagram.png 'Proof of transitivity, noncollinear case')\n"
"\n"
"Try to write the structure of this proof in *LEAN* and then fill in the sorries."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level08
msgid "Given three non-collinear points A, B, C and a line ‚Ñì, if A and B are on the same side of\n"
"‚Ñì and B and C are on the same side of ‚Ñì, then A and C are on the same side of ‚Ñì."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level09
msgid "Getting ready for the final level!"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level09
msgid "We are left with proving transitivity for collinear points. The trick in this case is to reduce to the known\n"
"case by a quite slick argument. The key step lies in the lemma below: given two lines $m$ and $\\ell$, and a point\n"
"$A$ on $m$ but not on $\\ell$, the goal is to find a new point $E$ which is not on $m$ and which is on the same side of $\\ell$\n"
"as $A$.\n"
"\n"
"Here is a sketch of the proof, most of which has been replicated already for you in **LEAN** code.\n"
"\n"
"1. Prove first that $\\ell$ and $m$ are distinct.\n"
"1. Let $D$ be a point on $\\ell$ not lying on $m$ (in particular, $D \\neq A$).\n"
"1. Using axiom (B2), find a point $E$ such that $D * A * E$. Let $s$ be the line through these points.\n"
"1. Prove that $E \n"
"otin \\ell$ (because $A \\notin \\ell$ and the intersection of $s$ and $\\ell$ already contains $D$). Note that this implies,\n"
"  in particular, that $\\ell ‚â† s$.\n"
"1. Prove that $E \\notin m$:\n"
"    - Suppose it where, and show in that case that m = s.\n"
"    - Since $D \\in s$ but $D \\notin m$ we get a contradiction.\n"
"1. Show that $A$ is on the same side as $E$:\n"
"    - If the segment $AE$ did meet $\\ell$, the intersection point would be $D$.\n"
"    - This would mean that $A * D * E$.\n"
"    - Since we also have $D * A * E$, we would get a contradiction.\n"
"\n"
"![Proof sketch](trans_collinear_diagram.png 'Proof of transitivity, collinear case')"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level09
msgid "Given lines $m$ and $\\ell$ and a point $A$ in $m$ and not in $\\ell$, there\n"
"exists a point $E$ not in $m$ on the same side of $\\ell$ as $A$."
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level10
msgid "The Final Level!"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level10
msgid "After all this hard work, we are left with the final task of assembling the bits and proving transitivity\n"
"in the collinear case. We will prove this by applying up to three times the noncollinear case already proven.\n"
"For this, we need the auxiliary point from the previous level. Here is a sketch of the proof.\n"
"\n"
"1. First, note that the case $A = B$, $A = C$ or $B = C$ are easy, and they can be proved separately. So we may\n"
"  assume for the rest of the proof that $A \\neq B$, $A \\neq C$ and $B \\neq C$.\n"
"1. Let $m$ be the line through $A$, $B$, $C$.\n"
"1. Consider the point $E$ obtained from the previous level, which is not in $m$ and is on the same side of $\\ell$ as $A$.\n"
"1. Show that the sets $\\{A, B, E\\}$, $\\{A, C, E\\}$ and $\\{B, C, E\\}$ are all non-collinear (they are all done similarly).\n"
"1. Using symmetry, and transitivity for non-collinear points, show that $B$ is on the same side as $E$.\n"
"1. Show, using the previous step and a similar argument, that $E$ is on the same side as  $C$.\n"
"1. Finally, finish the proof using a third time transitivity for non-collinear points.\n"
"\n"
"![Proof sketch](trans_collinear_diagram.png 'Proof of transitivity, collinear case']"
msgstr ""

#: Game.Levels.PlaneSeparationWorld.level10
msgid "Given three collinear points A, B, C and a line ‚Ñì, if A and B are on the same side of\n"
"‚Ñì and B and C are on the same side of ‚Ñì, then A and C are on the same side of ‚Ñì."
msgstr ""

#: Game.Levels.PlaneSeparationWorld
msgid "Plane Separation World"
msgstr ""

#: Game.Levels.PlaneSeparationWorld
msgid "# Plane Separation World\n"
"\n"
"## A new world of possibilities...\n"
"\n"
"The notion of **plane separation** comes from the fourth axiom of order, which is the Pasch's Axiom.\n"
"\n"
"**B.4) Pasch's Axiom:** Let A, B, C be three non-collinear points and let ‚Ñì be a line lying in the plane ABC\n"
"and not passing through any of the points A, B, C. Then, if the line ‚Ñì passes through a point of the segment A¬∑B,\n"
"it will also pass through either a point of the segment B¬∑C or a point of the segment A¬∑C (but not both).\n"
"\n"
"In Lean, the Pasch's Axiom is formalized as this statement, which you will find in the `Betweenness` tab.\n"
"\n"
"`lemma pasch {A B C D : Œ©} {‚Ñì : Line Œ©} (hnc: C ‚àâ line_through A B)\n"
"(hnAl: A ‚àâ ‚Ñì) (hnBl: B ‚àâ ‚Ñì) (hnCl: C ‚àâ ‚Ñì) (hDl: D ‚àà ‚Ñì) (hADB: A * D * B) :\n"
"(‚àÉ E ,  E ‚àà ‚Ñì ‚àß (A * E * C)) xor (‚àÉ E, E ‚àà ‚Ñì ‚àß (B * E * C))`\n"
"\n"
"![Axiom Pasch](pasch.png 'Pasch Axiom, the fourth axiom of betweenness')"
msgstr ""

#: Game
msgid "Hilbert Geometry Game"
msgstr ""

#: Game
msgid "Welcome to the Hilbert Geometry Game! Select an unlocked level to get started!"
msgstr ""

#: Game
msgid "Geometry Game. Based on Hilbert Game, and made for Argo Summer school (Univ. Aut√≤noma de Barcelona) 2024.\n"
"\n"
"Author: Marc Masdeu\n"
"Contributors: Carlos Caralps, Luis Castillo"
msgstr ""

#: Game
msgid "Hilbert Geometry"
msgstr ""

#: Game
msgid "Discover Lean through Hilbert's Geometry"
msgstr ""
